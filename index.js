"use strict";
import * as percom from "percom";
import * as clone from "clone";
import * as fs from "fs";
import * as serialize from "serialize-javascript";
import get from "lodash.get";
import md5 from "md5";
import { gzipSync, unzipSync } from "zlib";
import Events from "events";

const alphabet = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "Y",
  "Z",
];

const numbers = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];

function checkStream(obj) {
  return obj != null && typeof obj.pipe === "function";
}

function shuffleArray(array, shuffle = true) {
  if (!shuffle) return array;

  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }

  return array;
}

function getLength(alphabet, n) {
  for (let k = 2; k < alphabet.length; k++) {
    const p = percom.countPer(k, k);
    if (p >= n) return k;
  }
}

function getKeys(alphabet, n, shuffle = false) {
  const k = getLength(alphabet, n);
  const alphabets = alphabet.slice(0, k);
  const permutations = percom.per(alphabets, k);

  return shuffleArray(
    permutations.map((p) => p.join("")),
    shuffle
  );
}

function addToAlphabets(alphabet, seq) {
  seq.forEach((s) => {
    s.split("").forEach((k) => alphabet.add(k));
  });
}

function chunkString(str, length, tokenSeparator) {
  if (tokenSeparator) return str.split(tokenSeparator);
  return str.match(new RegExp(".{1," + length + "}", "g"));
}

function getKeyValue(str, keyLength) {
  const arr = str.split("");
  const key = arr.slice(0, keyLength).join("");
  const value = arr.slice(keyLength).join("");

  return [key, value];
}

export default class JSONSequencer extends Events {
  constructor({
    model,
    path,
    name = `model_${Date.now()}`,
    keys = [],
    skipKeys = [],
    mode = "alphabet",
    hashKVSeparator = "",
    keepAutogeneratedKeys = false,
    autofit = false,
    autofitFactor = 1,
    fillNA = false,
    NA = "X",
    uniformTokenLength = false,
    tokenSeparator = " ",
    keyAlphabet = alphabet,
    valuesAlphabet = numbers,
    verbose = false,

    filterData = () => false,
    translateKey = (k) => k,
    translateValue = (k, v) => v,
  }) {
    super();

    if (model) {
      this.extractDataFromModel(model);
      this.model = model;
    } else if (path) {
      this.loadModel(path);
    } else {
      this.model = { inverters: {} };
      this.keys = keys;
      this.skipKeys = skipKeys;
      this.keepAutogeneratedKeys = keepAutogeneratedKeys;
      this.fillNA = fillNA;
      this.uniformTokenLength = uniformTokenLength;
      this.NA = NA;
      this.keyAlphabet = keyAlphabet;
      this.valuesAlphabet = valuesAlphabet;
      this.tokenSeparator = tokenSeparator;
      this.autofitFactor = autofitFactor;
      this.autofit = autofit;
      this.mode = mode;
      this.hashKVSeparator = hashKVSeparator;
    }

    if (!this.name) this.name = name;
    if (!this.filterData) this.filterData = filterData;
    if (!this.translateKey) this.translateKey = translateKey;
    if (!this.translateValue) this.translateValue = translateValue;

    this.combinations = new Set();
    this.verbose = verbose;

    if (this.autofit && this.autofitFactor <= 0) this.autofitFactor = 1;
    if (this.mode === "hash") {
      this.uniformTokenLength = true;
      this.tokenLength = 32;
    }
  }

  getCombinations() {
    return this.combinations;
  }

  setParams({ skipKeys, filterData, translateKey, translateValue }) {
    if (skipKeys) this.skipKeys = skipKeys;
    if (filterData) this.filterData = filterData;
    if (translateKey) this.translateKey = translateKey;
    if (translateValue) this.translateValue;

    this.emit("model_update", this.getModel());
  }

  async fit({ data, dataPath, shuffleValueAlphabets = false }) {
    if (this.mode === "hash") throw new Error("No needed to fit model when in HASH Mode");

    const _keys = new Map();
    const _values = new Set();

    const df = {
      keysSize: 0,
      valuesSize: 0,
      translators: {},
      inverters: {},
      alphabets: new Set(),
    };

    data = checkStream(data) || Array.isArray(data) ? data : [data];
    for await (let row of data) {
      if (dataPath) row = get(row, dataPath);

      const campi = this.keys?.length > 0 ? this.keys : Object.keys(row);

      for (let key of campi) {
        if (!this.skipKeys.includes(key)) {
          key = this.translateKey(key);
          let value = get(row, key);
          if (value) {
            if (!_keys.has(key)) _keys.set(key, new Set());

            const values = Array.isArray(value) ? value : [value];
            for (let valore of values) {
              valore = this.translateValue(key, valore);
              _values.add(valore);
              _keys.get(key).add(valore);
            }
          }
        }
      }
    }

    df.keysSize += _keys.size;
    const keysAlpha = getKeys(
      this.keyAlphabet,
      _keys.size + (this.autofit ? this.autofitFactor : 0),
      shuffleValueAlphabets
    );
    addToAlphabets(df.alphabets, keysAlpha);

    let keyLength = keysAlpha[0].length;
    let valueLength = 0;
    let alfabetoValori = {};
    let maxAlphaValueSize = 0;

    for (const [key, value] of _keys.entries()) {
      const alphaValueSize =
        (this.uniformTokenLength ? _values.size : value.size) +
        (this.autofit ? this.autofitFactor : 0);

      if (alphaValueSize > maxAlphaValueSize) maxAlphaValueSize = alphaValueSize;
      const valuesAlpha = getKeys(this.valuesAlphabet, alphaValueSize, shuffleValueAlphabets);
      valueLength = valuesAlpha[0].length;
      addToAlphabets(df.alphabets, valuesAlpha);

      const valuesMap = new Map();
      const inverseValuesMap = new Map();
      for (const valore of [...value]) {
        if (this.filterData(key, valore)) continue;
        const valueKey = valuesAlpha.splice(0, 1)[0];
        valuesMap.set(valore, valueKey);
        inverseValuesMap.set(valueKey, valore);
      }

      alfabetoValori[key] = valuesAlpha;

      if (this.fillNA) {
        const missing = "Missing Value From Source";
        const valueKey = this.uniformTokenLength ? this.NA.repeat(valueLength) : this.NA;
        valuesMap.set(missing, valueKey);
        inverseValuesMap.set(valueKey, missing);
      }

      const chiave = keysAlpha.splice(0, 1)[0];
      df.translators[key] = { key: chiave, values: valuesMap };
      df.inverters[chiave] = { key, values: inverseValuesMap };
    }

    df.alphabets = [...df.alphabets];

    if (this.fillNA) {
      df.alphabets.unshift(this.NA);
    }
    if (this.tokenSeparator) {
      df.alphabets.unshift(this.tokenSeparator);
    }

    df.alphabets = df.alphabets.sort();

    if (this.uniformTokenLength) {
      df.keyLength = keyLength;
      df.valueLength = valueLength;
      df.tokenLength = keyLength + valueLength;
    }

    df.updater = { keys: keysAlpha, values: alfabetoValori };

    df.valuesSize = _values.size;
    df.maxAlphaValueSize = maxAlphaValueSize;
    this.model = df;

    if (this.verbose) console.log(df);
    this.emit("fitted");
  }

  _update(key, value, shuffleValueAlphabets) {
    try {
      // Missing Key
      if (!value) {
        const chiave = this.model.updater.keys.splice(0, 1)[0];
        if (chiave) {
          this.model.translators[key] = { key: chiave, values: new Map() };
          this.model.inverters[chiave] = { key: key, values: new Map() };
          this.model.updater.values[key] = getKeys(
            this.valuesAlphabet,
            this.model.maxAlphaValueSize,
            shuffleValueAlphabets
          );
          this.model.keysSize += 1;

          return this.model.translators[key];
        }
      }

      const valore = this.model.updater.values[key].splice(0, 1)[0];

      if (valore) {
        const { key: chiave, values } = this.model.translators[key];
        values.set(valore, key);
        this.model.inverters[chiave].values.set(key, valore);
        this.model.valuesSize += 1;
        return valore;
      }
    } catch (error) {}
  }

  async transform({ data, dataPath, outputStream, cb, shuffleValueAlphabets = false }) {
    if (outputStream && !checkStream(outputStream)) {
      throw new Error("outputStream must be a writable stream");
    }

    if (cb && !typeof cb === "function") {
      throw new Error("Callback must be a function");
    }

    let modelUpdated = false;
    const results = [];
    const errors = [];
    const isHash = this.mode === "hash";
    const isStream = checkStream(data);
    const multiple = Array.isArray(data);
    if (!multiple && !isStream) data = [data];

    // if (this.mode === "hash")
    //   return this.transformHASH({ data, dataPath, multiple, outputStream, cb });

    for await (let chunk of data) {
      const row = dataPath ? get(chunk, dataPath) : chunk;
      const campi = (() => {
        if (this.keys?.length > 0) return this.keys;

        const autoKeys = Object.keys(row);
        if (this.keepAutogeneratedKeys) {
          this.keys = autoKeys;
          modelUpdated = true;
        }

        return autoKeys;
      })();
      const d = [];

      for (let key of campi) {
        if (!this.skipKeys.includes(key)) {
          key = this.translateKey(key);
          const value = get(row, key);

          let translate = this.model?.translators?.[key];

          if (!translate && !isHash) {
            if (this.autofit) {
              translate = this._update(key, null, shuffleValueAlphabets);
              if (!translate) {
                errors.push(`Model autofit is out of capacity. Not able to update for key ${key} `);
                continue;
              } else modelUpdated = true;
            } else {
              errors.push(`Key ${key} is not in the Model. Maybe you should refit it.`);
              continue;
            }
          }

          if (value) {
            const values = Array.isArray(value) ? value : [value];
            for (let valore of values) {
              if (this.filterData(key, valore)) continue;

              valore = this.translateValue(key, valore);
              let translated = translate?.values?.get?.(valore);

              if (!translated && !isHash) {
                if (this.autofit) {
                  translated = this._update(key, valore, shuffleValueAlphabets);
                  if (translated) modelUpdated = true;
                }
              }

              if (isHash) {
                const seq = md5(`${key}${this.hashKVSeparator}${valore}`);
                d.push(seq);
                this.combinations.add(seq);
                this.model.inverters[seq] = { key, value: valore };
              } else if (translated) {
                const seq = `${translate.key}${translated}`;
                d.push(seq);
                this.combinations.add(seq);
              } else
                errors.push(
                  this.autofit
                    ? `Model autofit is out of capacity. Not able to update  ${valore} for key ${key}`
                    : `Value ${valore} for key ${key} is not in the Model. Maybe you should refit it.`
                );
            }
          } else if (this.fillNA) {
            if (this.uniformTokenLength) {
              if (isHash) {
                const seq = `${key}${this.hashKVSeparator}${this.NA.repeat(
                  this.model.valueLength
                )}`;
                d.push(md5(seq));
                this.model.inverters[seq] = { key, value: this.NA };
              } else d.push(translate.key + this.NA.repeat(this.model.valueLength));
            } else {
              d.push(`${translate.key}${this.NA}`);
            }
          }
        }
      }

      const seq = d.join(this.tokenSeparator);

      if (this.verbose) console.log(seq.length, seq);

      this.emit("transform_data", { sequence: seq, chunk });

      if (outputStream) outputStream.write({ sequence: seq, chunk });
      if (cb) cb(errors, seq, chunk);
      if (!outputStream && !cb) results.push(seq);
    }

    this.emit("transformed", results, errors);
    if (modelUpdated) this.emit("model_update", this.getModel());

    return [multiple ? results : results[0], errors];
  }

  fit_transform({
    data,
    transformData,
    dataPath,
    outputStream,
    cb,
    shuffleValueAlphabets = false,
  }) {
    if (isStream(data) && !transformData)
      throw new Error("Fit data is a stream you must provide transformData");

    this.fit({ data, shuffleValueAlphabets, dataPath });
    return this.transform({
      data: transformData ?? data,
      outputStream,
      cb,
      dataPath,
      shuffleValueAlphabets,
    });
  }

  async invert({ data, dataPath, outputStream, cb }) {
    if (!this.uniformTokenLength && !tokenSeparator) {
      throw "The Model has not fixed token length. You Should specify a token separator.";
    }

    if (outputStream && !checkStream(outputStream)) {
      throw new Error("outputStream must be a writable stream");
    }

    if (cb && !typeof cb === "function") {
      throw new Error("Callback must be a function");
    }

    const errors = [];
    const results = [];
    const isStream = checkStream(data);
    const multiple = Array.isArray(data);
    if (!multiple && !isStream) data = [data];

    const tokenLength = this.tokenLength;
    const keyLength = this.keyLength;

    if (tokenLength || this.tokenSeparator) {
      for await (let row of data) {
        if (dataPath) row = get(row, dataPath);

        for (const token of chunkString(row, tokenLength, this.tokenSeparator)) {
          let ret;

          if (mode === "hash") {
            ret = this.model.inverters[key];
          } else {
            const [key, value] = getKeyValue(token, keyLength);
            const k = this.model.inverters[key];

            if (k) {
              const v = k.values.get(value);
              if (v) {
                ret = [k.key, k.values.get(value)];
              }
            }
          }

          if (ret) {
            this.emit("invert_data", ret);

            if (outputStream) outputStream.write(ret);
            if (cb) cb(errors, ret);
            if (!outputStream && !cb) results.push(ret);
          } else errors.push(`Key ${key} is not in the Model. Maybe you should refit it.`);
        }
      }
    } else errors.push("No Valid Model Loaded");

    return [multiple ? results : results[0], errors];
  }

  getAlphabets() {
    if (this.model && this.model.alphabets) {
      return this.model.alphabets;
    }
  }

  extractDataFromModel(raw) {
    const decompressed = unzipSync(raw);
    const model = eval("(" + decompressed + ")");

    this.name = model.name;
    this.keys = model.fields;
    this.skipKeys = model.skipKeys;
    this.fillNA = model.fillNA;
    this.uniformTokenLength = model.uniformTokenLength;
    this.NA = model.NA;
    this.keyAlphabet = model.keyAlphabet;
    this.valuesAlphabet = model.valuesAlphabet;
    this.filterData = model.filterData;
    this.translateKey = model.translateKey;
    this.translateValue = model.translateValue;
    this.tokenSeparator = model.tokenSeparator;
    this.autofit = model.autofit;
    this.autofitFactor = model.autofitFactor;
    this.keepAutogeneratedKeys = model.keepAutogeneratedKeys;
    this.mode = model.mode;
    this.hashKVSeparator = model.hashKVSeparator;

    return model;
  }

  getModel() {
    if (this.model) {
      const model = clone.default(this.model);
      model.name = this.name;
      model.fields = this.keys;
      model.skipKeys = this.skipKeys;
      model.fillNA = this.fillNA;
      model.uniformTokenLength = this.uniformTokenLength;
      model.NA = this.NA;
      model.tokenSeparator = this.tokenSeparator;
      model.keyAlphabet = this.keyAlphabet;
      model.valuesAlphabet = this.valuesAlphabet;
      model.filterData = this.filterData;
      model.translateKey = this.translateKey;
      model.translateValue = this.translateValue;
      model.autofit = this.autofit;
      model.autofitFactor = this.autofitFactor;
      model.keepAutogeneratedKeys = this.keepAutogeneratedKeys;
      model.mode = this.mode;
      model.hashKVSeparator = this.hashKVSeparator;
      model.creationDate = Date.now();

      const serialized = serialize.default(model);
      const compressed = gzipSync(Buffer.from(serialized));

      if (model.translators) {
        Object.keys(model.translators).forEach((key) => {
          model.translators[key].values = [...model.translators[key].values];
        });
      }

      if (model.inverters) {
        if (this.mode !== "hash") {
          Object.keys(model.inverters).forEach((key) => {
            model.inverters[key].values = [...model.inverters[key].values];
          });
        }
      }

      return [compressed, model];
    }
  }

  saveModel({ dir, generateJSONCopy = false }) {
    if (!dir) throw new Error("No Path to Save Model");

    if (this.model) {
      const [compressed, model] = this.getModel();

      if (!dir.endsWith("/")) dir = `${dir}/`;
      if (generateJSONCopy) {
        fs.writeFileSync(`${dir}${model.name}.json`, JSON.stringify(model, null, 1));
      }

      fs.writeFileSync(`${dir}${model.name}.j2s`, compressed);

      this.emit("model_save", compressed, model);
      return [compressed, model];
    } else throw new Error("No Model To Save");
  }

  loadModel(path) {
    const model = this.extractDataFromModel(fs.readFileSync(path));

    if (this.verbose) console.log(model);

    this.model = model;
    this.emit("model_loaded", model);
  }

  setModel(raw) {
    const model = this.extractDataFromModel(raw);

    if (this.verbose) console.log(model);

    this.model = model;
    this.emit("model_set", model);
  }
}
